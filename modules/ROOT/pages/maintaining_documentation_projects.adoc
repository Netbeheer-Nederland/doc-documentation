= Maintaining Documentation Projects

****
image::proc_maintaining_doc_proj.drawio.svg[]
****

== Creating a documentation project

****
image::proc_create_doc_proj.drawio.svg[]
****

Each documentation project is maintained in its own Git repository and needs to conform to a certain structurefootnote:[Each documentation project corresponds to an Antora component, so it must have a component version descriptor (an `antora.yml` file) and modules (a `modules` directory).] in order for the documentation website to be able to integrate it.

=== Creating a Git repository from template

.Instructions
. Visit the https://github.com/Netbeheer-Nederland/tmpl-doc/[documentation project template repository] in your browser.
. Click the _Use this template_ button located at the top-right and choose _Create a new repository_ from the emerging dropdown:
+
image::use_tmpl_button.png[]
+
. Fill in the form to create the repository:
+
.Fill in details to create the repository
====
image::create_git_repo.png[]
====
+
.. Set the repository owner to _Netbeheer-Nederland_.
.. Provide a name for the repository. Make sure to follow the naming conventionsfootnote:[For now, it suffices to start the name with `doc-`, and write the rest of the name in `lower-kebab-case`.].
.. Provide a description for the repository.
.. Set the repository visibility to _Public_.
. After clicking _Create repository_ you should be redirected to your new Git repository.

=== Configuring the project

You've now successfully bootstrapped a documentation project. Now let's configure it.

.Instructions
. Open the `antora.yml` filefootnote:[The presence of this file tells you the directory contains an Antora component version.] at the root of the project and edit according to the following instructions:
+
[source,yaml]
....
name: modeling-guide <1>
title: Modeling Guide <2>
version: true <3>
start_page: index.adoc <4>
nav:
- modules/ROOT/nav.adoc <5>
....
<1> The `name` value uniquely identifies the project within the entire documentation site. It is used, for example, to do cross-referencing from one project to another. Please follow naming conventionsfootnote:[For now, write the entire name in `lower-kebab-case`.].
<2> A `title` for your project, suited for presentation on the documentation website.
<3> Use `version` to describe the version of the project. It is strongly advised to set this to `true`, causing the version identifier to follow Gitfootnote:[This plays nicely with the Antora playbook used by the root documentation project to generate the website. Since there you can specify patterns for matching certain branches or tags, that will dictate what version identifier the component shows.].
<4> The start or root page of the project. It defaults to `index.adoc` footnote:[The page path entered is not a regular file path, but an https://docs.antora.org/antora/latest/page/resource-id/#whats-a-resource-id[Antora resource ID].], but you can set it to a different name here.
<5> Under the `nav` key you can specify https://docs.antora.org/antora/latest/navigation/files-and-lists/#whats-a-nav-file[navigation files] to structure the pages in the project.
+
. Save, commit and push the changes.

'''

Please refer to the Antora documentation for more details on https://docs.antora.org/antora/latest/playbook/[configuring the Antora playbook] and https://docs.antora.org/antora/latest/component-version-descriptor/[`antora.yml`].

=== Registering the new project with the root documentation project

The documentation website can only show projects it is aware of. Whenever a documentation project is created or renamed, the root documentation project which generates the website must be made aware of this. Since site generation is configured through an Antora playbook (`antora-playbook.yml`), we will proceed to make the necessary changes there.

.Instructions
. Have the https://github.com/Netbeheer-Nederland/docs/[root documentation project Git repository] checkout out.
. Open `antora-playbook.yml`, look for the `content` key and follow instructions:
+
[source,yaml]
....
content:
  sources: <1>
  - url: . <2>
    branches: HEAD
    start_path: ./root_component
  - url: https://github.com/Netbeheer-Nederland/doc-documentation-manual <3>
    tags: v*
  - url: https://github.com/Netbeheer-Nederland/doc-modeling-guide <4>
    tags: v*
....
<1> The `sources` key under `content` is where _content sources_ are specified. Documentation projects must be added here in order to be integrated.
<2> You can ignore the content source which has a relative URLfootnote:[This is the root component.].
<3> Items with an absolute URL point to documentation projects.
<4> To register a new documentation project, add a new item to the list. Provide a `url` entry which points to the project's Git repository, and add the entry `tags: v*` to exclusively aggregate content from tags starting with a `v` footnote:[This facilitates how we wish to manually control releasing new versions. See: <<_releasing_a_version>>.].
+
. Make the new project findable by adding it to the site navigation. This is done by editing the root component's `nav.adoc`:
+
[source,adoc]
....
* xref:documentation-manual::index.adoc[Home] <1>
* Modeling Guide <2>
** xref:modeling-guide::index.adoc[] <3>
....
<1> Navigation files are lists. Also, by providing text between the brackets (`[]`) you can set the link text.
<2> You don't have to exclusively write references. Using plain text headers can sometimes be beneficial for structuring the content.
<3> Add references for all pages in any structure you see fit. Note you can leave the text between the brackets empty, automatically causing the link text to be the referenced page's title.
+
. Commit and push these changes to the `main` branch.
. Make sure to <<_rebuild_documentation_website,rebuild the documentation website>> once you wish to actually see the new documentation project appear on the website.

== Creating a new draft

****
image::proc_create_new_draft_branch.drawio.svg[]
****

To make changes you need to create a draft. Drafts are tracked in Git in dedicated branches called _draft branches_. Depending on what major version(s) you are working on, you choose a different _version branch_ footnote:[Each major version has a dedicated branch in Git called a _version branch_. These branches enable simultaneous maintenance on multiple major versions.] to branch off for your draft. If you know in advance the changes will constitute a major version increment, you can create a new version branch beforehand.

[NOTE]
Even though your draft branch will originate from one version branch, it is possible to merge it onto several version branches. This can be useful in scenarios such as fixing a typo that is present in more than one of the major versions.

=== Creating a version branch

.New version branch `v1`
====
// Mermaid Gitgraph
////
%%{init: { 'gitGraph': {'mainBranchName': 'v0', 'showBranches': true, 'parallelCommits': false}} }%%
gitGraph
  commit
  commit
  branch v1
  checkout v1
  commit
////
image::ex_creating_version_branch.png[width=33%]
====

If you want to create a new version branch, simply create a new branch on the Git repository following the naming scheme `vM`, where `v` stands for 'version' and `M` is a number denoting the major version.

The following example shows how to do this on the CLI using `git`.

.Creating new version branch `v1` using `git` on the CLI
====
[source,shell]
....
$ git checkout v0 <1>
$ git checkout -b v1 <2>
$ git push -u origin v1 <3>
....
<1> Checkout the revision you wish to start a new version from. Here we use the `HEAD` of the `v0` version branch.
<2> Create a new version branch with the major version incremented by `1` and switch to it.
<3> Set the remote tracking branch for the new branch.
====

=== Creating a draft branch

.New draft branch `v1.new-logo`
====
// Mermaid Gitgraph
////
%%{init: { 'gitGraph': {'mainBranchName': 'v0', 'showBranches': true, 'parallelCommits': false}} }%%
gitGraph
  commit
  commit
  branch v1
  checkout v1
  commit
  commit
  branch v1.new-logo
  commit
  commit
////
image::ex_creating_draft_branch.png[width=50%]
====

Pick a version branch to branch the draft off of. Draft branches follow the naming convention: `vM.draft-name`, where `vM` is the name of the version branch, and `draft-name` is a name of the draft. It is recommended to choose a name that expresses the intent of the work done in the draft.

[NOTE]
It may seem like a good idea to also allow (or even prefer) draft branches to be based on releases, such as `v2.3.stakeholders-update`. However, you could wonder useful this really is. First of all, releases are tags, while it is more common and easier to branch off of a branch `HEAD`. Also, there's no real benefit, since often several drafts are being worked on for the same major version, and likely several of those are merged simultaneously leading to a new release.

// TODO: Doesn't the minor version help communicating the correct merge order?

The following example shows how to do this on the CLI using `git`.

.Creating new draft branch `v1.new-logo` using `git` on the CLI
====
[source,shell]
....
$ git checkout v1 <1>
$ git checkout -b v1.new-logo <2>
$ git push -u origin v1.new-logo <3>
....
<1> Checkout the version branch you wish to start a new draft for. Here we use the `HEAD` of the `v1` version branch.
<2> Create a new draft branch and switch to it.
<3> Set the remote tracking branch for the new branch.
====

== Working on a draft

****
image::proc_working_on_draft.drawio.svg[]
****

=== Writing content

// TODO: Refer to dedicated chapter.
Here, only a short summary is given to get you started. At some point a more extensive guide on how to write content and leverage helpful tooling will have to be written.

==== Write content in AsciiDoc

Content is written in the AsciiDoc markup language. Its well-standardized and expressive plaintext nature is what we require for our durable, documentation as code workflow. You can read more about our motivation for documentation as code and AsciiDoc xref::docs_as_code.adoc[here].

You can write AsciiDoc in any IDE or text editor. For learning the language refer to the large variety of resources on the web.
// TODO: Refer to some helpful resources such as AsciiDoctor's primer, the AsciiDoc website and perhaps some other tutorials or guides?

==== Use Antora resource IDs instead of local paths

[IMPORTANT]
We make use of Antora for coordination and aggregation of documentation projects. When cross-referencing resources, do not use relative paths, but use Antora resource IDs. Read more on why this is encouraged https://antora.zulipchat.com/#narrow/stream/282400-users/topic/Local.20references.20compatible.20with.20both.20Antora.20and.20AsciiDoctor[in this issue].

==== Embedding Diagrams.net (draw.io) images

Diagrams.net drawings are used extensively in our documentation. For greatly enhanced maintainability the following way of working is advised:

.Instructions

. Create and edit your diagrams in the Diagrams.net application, web or desktop.
. Export the diagram to the SVG or PNG format
.. This can be found under _File > Export as > ..._
.. *Important*: save a copy of the diagram inside the image so you can edit it later:
+
image::ex_save_drawio_include_diagram.png[]
+
. Save the image to the `modules/ROOT/images` directory of your project.
. Use the `image` macro to show the image at the desired place in your document(s). For example:
+
[source,asciidoc]
....
image::my_diagram.png[]
....
+
. You can edit the diagram by opening the image in the Diagrams.net application.

[TIP]
--
You can use hyperlinks in the diagram to jump to associated sections in your document by adding those relative anchors as links in Diagrams.net. For this to work you need to pass the `opts=interactive` attribute value to the `image` macro.

Note that this seems to work only with the desktop application, since the web app exports absolute URLs that are relative to the Diagrams.net web app.
--

=== Editor and IDE support

As discussed, AsciiDoc is plaintext and can be edited in any editor. However, editing this way can become quite tedious unless you use an editor with more advanced features.

Features to be looking for:

* Syntax highlighting
* Autocompletion of AsciiDoc macros and constructs
* Automatic checking for dead references
* Syntax validation and linting to help with writing correct code
* Live previewing of rendered documentation
* Navigating between files with jumps and using a file explorer
* Git support

This is not an exhaustive list of course, but if an editor supports the majority of these features it will really make your life easier.

Following are some suggestions for IDEs which are popular, easy to use and support good plugins for working with AsciiDoc.

==== IntelliJ IDE

The IntelliJ IDEs are famous for their full-featured integrated development environment where basically everything is taken care of.

Where it stands out:

* Powerful, accessible yet highly customizable UI
* Best https://plugins.jetbrains.com/plugin/7391-asciidoc[AsciiDoc plugin] currently available
** Autocompletion works really well
** Live preview pane, including diagrams as code
** Antora aware, so it provides a lot of help with cross-references as well
* Great support for Git built-in

[TIP]
Get a free version of the application by looking for the _Community Edition_.

==== Visual Studio Code

Another greater editor for writing AsciiDoc is Visual Studio Code.

It comes with a lot less batteries included than IntelliJ's IDEs, but that could be a feature depending on your preferences.

Where it stands out:

* Lean, simple editor but with a great host of extensions available that are easy to install
* Very decent AsciiDoc plugin available, although not quite as powerful as the IntelliJ one
** It's Antora awareness is limited at best, not working at worst. This means live previewing is very limited as well at least for our projects.
* Great support for Git built-in

==== Other editors

There are plugins for Emacs and Vim as well, and likely for many more editors. However, nothing seems to give as much of a fully featured and integrated experience as the IntelliJ IDE does with its AsciiDoc plugin, so that one is highly recommended.

If you do decide to use some other editor, just be aware that previewing will very likely not work with anything that's referenced through Antora resource IDs such as partials and images. Since we do <<_use_antora_resource_ids_instead_of_local_paths,use Antora resource IDs for every reference>>, this means all partial including and image rendering won't work in the preview. Luckily we can preview in other ways as well.

=== Previewing changes

Luckily it's not an absolute requirement that our IDE provides a live preview as we type. In fact, this preview is inherently limited in the first place, since it renders in a different way and context than the eventual Antora setup would.

==== Running Antora locally
To preview the entire documentation website as it would be rendered in production, but locally including your changes, you can run Antora locally.

See: xref::using_antora_locally.adoc[].

=== Committing new changes

Since we rely on Git for versioning, much of the best practices that apply generally when working with Git also apply here.

A few words of advice that cannot be repeated enough:

* Keep commits small.
* Provide descriptive commit messages that are as short and to the point as possible.

.Small commits and short commit messages
****
*_Overview_*. +
Small commits help with maintaining overview on what you are doing and have done, since small units of work are easier to describe well, and having many of such messages listed chronologically really paints a good picture of your process.

*_Fine-grained rollback_*. +
This also enables fine-grained rolling back of commits whenever something turned out to be a mistake for example. Imagine having to roll back a gigantic load of work just to revert some erroneous paragraph: not a great experience.

*_Collaboration_*. +
It's not just you help out this way, but other collaborators too. When they <<_receiving_feedback,review your work>>, it's very helpful if there's a bunch of helpful commit messages to guide them. Moreover, a commit is an event than be used to trigger a call to action for reviewing. Short review cycles can work wonders, and this way they are easier to do.

*_Releasing_*. +
Finally, having small commits also helps with releasing. Merging many small commits means having a lot of control over what set of commits to regard a new release.
****

=== Syncing changes to the remote Git repository

After having committed a bunch of changes locally, you can sync changes to the remote Git repository simply by using a Git `push`.

How often to push is a matter of debate but also taste. Reasons to push often include:

* <<_receiving_feedback,Receiving feedback>> through a GitHub (draft) pull request requires the commits to be pushed to the remote.
* Local work could get lost due to hardware failure or viruses, although this is usually not a realistic concern since unless you push really rarely which is discouraged anyway.

=== Receiving feedback

****
image::proc_reviewing_and_discussion.drawio.svg[]
****

To receive feedback we advise using GitHub draft pull requests, i.e. pull requests with the _draft_ status.

==== Creating a draft pull request

From the https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request[GitHub documentation]:

[quote]
To create a pull request that is ready for review, click Create Pull Request. To create a draft pull request, use the drop-down and select Create Draft Pull Request, then click Draft Pull Request.

.Create a draft pull request
[#create_draft_pr]
====
image::ex_change_pr_to_draft.png[]
====

==== Reviewing and discussion on GitHub

Once the PR is created, you can start a review. In a review you can provide comments through inline threads where collaborators can discuss.

.Instructions
. Click the _Files changed_ tab:
+
image::ex_pr_files_changed_tab.png[]
+
. Scroll down to read what has been changed.
. When you like to comment, click the `+` icon that appears when hovering over a line:
+
image::ex_pr_comment.png[]
+
.. Click _Add single comment_ to start a thread for this line:
. Other collaborators can now discuss the feedback with you in that thread:
+
image::ex_pr_thread.png[]
+
.. Once a discussion is settled, you can resolve the thread by clicking _Resolve conversation_.

[TIP]
Once you've obtained feedback, you can make changes, push those to the GitHub repository and the pull request will pick up on those changes. This means you can keep a draft pull request open for as long as you keep working on it, and have a single place where you can periodically ask for feedback.

== Finishing drafts

****
image::proc_finish_draft.drawio.svg[]
****

Once a draft is finished, it should be merged onto the version branch it originated fromfootnote:[Potentially it could be merged onto multiple version branches, but that should be a rare scenario you should be cautious about.]. Preferably this is done through a pull request on GitHub, so collaborators can review the changes before performing the merge.

Following the merge, you can choose whether to <<_releasing_a_version,release a new version>> of the documentation project or not.

=== Creating a pull request

If there is an outstanding draft pull request you were using, it is easiest to convert that one into a regular pull request. You can find detailed instructions on the GitHub documentation: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/changing-the-stage-of-a-pull-request##marking-a-pull-request-as-ready-for-review[Marking a pull request as ready for review].

Otherwise, simply create a regular pull request. This too is detailed extensively in the GitHub documentation: https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request[Creating a pull request].

=== Reviewing and discussion

Most of the reviewing and discussion process is the <<_reviewing_and_discussion_on_github,same as for draft PRs>>. Please refer to the instructions already provided.

[NOTE]
One notable distinction, however, is that repositories could have rules set up which require a certain minimal amount of reviewers who have approved the changes made. Only once this constraint has been satisfied will it be possible to merge the branch.

=== Merging the draft branch

.Merging a draft branch
====
// Mermaid Gitgraph
////
%%{init: { 'gitGraph': {'mainBranchName': 'v1'}} }%%
gitGraph
  commit
  commit
  branch v1.new-logo
  commit
  commit
  checkout v1
  merge v1.new-logo
////
image::ex_merging_draft_branch.png[width=50%]
====

As soon as the reviewing is done and the changes are approved by the reviewers, you can merge the draft branch:

.Merging the draft branch
image::ex_pr_merge.png[]

After the merging has succeeded, it is good practice to delete the draft branch.

=== To release or not to release

You finished your draft, does this mean you have to create a new release? That's up to you.

Sometimes, the finishing of a draft makes for a good reason to release a new version. Other times, you may want to wait for additional work to be done before releasing a new version.

== Releasing a version

****
image::proc_release_new_version.drawio.svg[]
****

To mark a revision as a new version, all you need to do is tag a commit with version number. The root documentation project scans all projects for these tags and aggregates all versions of all projects that way.

Once the new release is created, make sure to rebuild the documentation website in order for the changes to become visible on the website.

=== Create a tag for your release

.Tagging a version creates a new version
// Mermaid Gitgraph
////
%%{init: { 'gitGraph': {'mainBranchName': 'v1'}} }%%
gitGraph
  commit
  commit tag: "v1.0"
  commit
  branch v1.new-logo
  commit
  commit
  checkout v1
  merge v1.new-logo tag: "v1.1"
////
image::ex_tagging_version.png[width=50%]

You can create a tag from your IDE or using the `git` CLI tool, or using the GitHub website which is probably easiest.

==== Create a release on GitHub

The easiest way to create tags is to create a new release on GitHub. To do this, visit the GitHub repository of your documentation project in your browser and follow these instructions:

.Instructions
. Create a new release by clicking the link at the bottom of the right pane:
+
image::ex_create_release_btn.png[]
+
. Enter a tag name and click _Create new tag_.
+
image::ex_create_release_tag.png[]
+
. Fill in the version number for the release name, and provide release notes.
+
image::ex_create_release_details.png[]
.. Note you can mark the release as not ready for production by checking the _Set as a pre-release_ box.
. Click _Publish release_ when you're done.

You've now released a new version of this documentation project. Make sure to rebuild the documentation website to see the new release featured.

[NOTE]
The process diagram speaks of pushing changes, referring to the newly created tag. However, using the GitHub website to create a tag as we've done makes this step redundant since it's already done on the remote repository.

== Rebuild documentation website

Rebuilding the documentation website is a manual action:

.Instructions
. Visit the root documentation project repository on GitHub in your browser.
. Click _Actions_ in the top toolbar.
. You should now be presented this screen:
+
image::trigger_git_workflow_publish_gh_pages.png[]
+
.. Select the action _Publish to GitHub Pages_ on the left sidebar.
.. Click the _Run workflow_ button, and then the green _Run workflow_ button.
. This will create a new run. Its status is indicated by the icon prefixing the line. As soon as it turns green, the new site is built and deployed.

[TIP]
Sometimes when you refresh the documentation website in your browser, the new changes won't show up. Oftentimes cache is the culprit here. Try hard reloading the page in your browser, for example pressing kbd:[Ctrl+Shift+R] in Google Chrome.

